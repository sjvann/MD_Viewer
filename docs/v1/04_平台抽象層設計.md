# 平台抽象層設計文件

## 1. 平台抽象層概述

平台抽象層 (Platform Abstraction Layer, PAL) 用於封裝平台特定的實作，提供統一的介面給上層服務使用。

### 1.1 設計目標

- **統一介面**：不同平台使用相同的介面
- **平台隔離**：平台特定程式碼集中管理
- **易於測試**：可為測試提供模擬實作
- **易於擴充**：新增平台時只需實作介面

## 2. 核心介面定義

### 2.1 IPlatformFileSystem

```csharp
namespace MD_Viewer.Services.Platform;

/// <summary>
/// 平台特定檔案系統介面
/// </summary>
public interface IPlatformFileSystem
{
    /// <summary>
    /// 取得平台特定的磁碟/根目錄列表
    /// </summary>
    Task<List<DriveInfo>> GetDrivesAsync();

    /// <summary>
    /// 請求檔案存取權限
    /// </summary>
    Task<string?> RequestFileAccessAsync();

    /// <summary>
    /// 請求目錄存取權限
    /// </summary>
    Task<string?> RequestDirectoryAccessAsync();

    /// <summary>
    /// 檢查是否有檔案存取權限
    /// </summary>
    Task<bool> HasFileAccessAsync(string path);

    /// <summary>
    /// 取得應用程式資料目錄
    /// </summary>
    string GetAppDataDirectory();

    /// <summary>
    /// 取得暫存目錄
    /// </summary>
    string GetTempDirectory();
}
```

## 3. Windows 平台實作

### 3.1 WindowsFileSystem

```csharp
#if WINDOWS
namespace MD_Viewer.Platforms.Windows;

using MD_Viewer.Services.Platform;
using MD_Viewer.Models;

public class WindowsFileSystem : IPlatformFileSystem
{
    public async Task<List<DriveInfo>> GetDrivesAsync()
    {
        return await Task.Run(() =>
        {
            var drives = new List<DriveInfo>();
            
            foreach (var drive in System.IO.DriveInfo.GetDrives())
            {
                if (drive.IsReady)
                {
                    drives.Add(new DriveInfo
                    {
                        Name = drive.Name,
                        Label = drive.VolumeLabel,
                        Path = drive.RootDirectory.FullName,
                        IsReady = true,
                        TotalSize = drive.TotalSize,
                        AvailableSpace = drive.AvailableFreeSpace
                    });
                }
            }
            
            return drives;
        });
    }

    public async Task<string?> RequestFileAccessAsync()
    {
        // Windows 可以直接存取檔案系統，無需特殊權限請求
        // 但可以使用 FilePicker 讓使用者選擇檔案
        return await Task.FromResult<string?>(null);
    }

    public async Task<string?> RequestDirectoryAccessAsync()
    {
        // 使用 Windows 的 FolderPicker
        var folderPicker = new Windows.Storage.Pickers.FolderPicker();
        folderPicker.FileTypeFilter.Add("*");
        
        var folder = await folderPicker.PickSingleFolderAsync();
        return folder?.Path;
    }

    public async Task<bool> HasFileAccessAsync(string path)
    {
        return await Task.Run(() =>
        {
            try
            {
                return Directory.Exists(path) || File.Exists(path);
            }
            catch
            {
                return false;
            }
        });
    }

    public string GetAppDataDirectory()
    {
        return Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
            "MD_Viewer"
        );
    }

    public string GetTempDirectory()
    {
        return Path.GetTempPath();
    }
}
#endif
```

## 4. macOS 平台實作

### 4.1 MacFileSystem

```csharp
#if MACCATALYST
namespace MD_Viewer.Platforms.MacCatalyst;

using MD_Viewer.Services.Platform;
using MD_Viewer.Models;
using AppKit;

public class MacFileSystem : IPlatformFileSystem
{
    public async Task<List<DriveInfo>> GetDrivesAsync()
    {
        // macOS 沒有傳統的磁碟概念
        // 返回常用目錄
        return await Task.FromResult(new List<DriveInfo>
        {
            new DriveInfo
            {
                Name = "主目錄",
                Label = "Home",
                Path = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
                IsReady = true
            },
            new DriveInfo
            {
                Name = "桌面",
                Label = "Desktop",
                Path = Path.Combine(
                    Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
                    "Desktop"
                ),
                IsReady = true
            },
            new DriveInfo
            {
                Name = "文件",
                Label = "Documents",
                Path = Path.Combine(
                    Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
                    "Documents"
                ),
                IsReady = true
            }
        });
    }

    public async Task<string?> RequestFileAccessAsync()
    {
        return await MainThread.InvokeOnMainThreadAsync(() =>
        {
            var openPanel = new NSOpenPanel
            {
                CanChooseFiles = true,
                CanChooseDirectories = false,
                AllowsMultipleSelection = false,
                AllowedContentTypes = new[] { 
                    UTType.CreateFromExtension("md") 
                }
            };

            if (openPanel.RunModal() == 1)
            {
                return openPanel.Url?.Path;
            }

            return null;
        });
    }

    public async Task<string?> RequestDirectoryAccessAsync()
    {
        return await MainThread.InvokeOnMainThreadAsync(() =>
        {
            var openPanel = new NSOpenPanel
            {
                CanChooseFiles = false,
                CanChooseDirectories = true,
                AllowsMultipleSelection = false,
                CanAccessSubdirectories = true
            };

            if (openPanel.RunModal() == 1)
            {
                return openPanel.Url?.Path;
            }

            return null;
        });
    }

    public async Task<bool> HasFileAccessAsync(string path)
    {
        return await Task.Run(() =>
        {
            try
            {
                // macOS 沙盒環境下需要檢查權限
                var securityScopedResource = new NSSecurityScopedResource();
                return Directory.Exists(path) || File.Exists(path);
            }
            catch
            {
                return false;
            }
        });
    }

    public string GetAppDataDirectory()
    {
        return Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
            "Library",
            "Application Support",
            "MD_Viewer"
        );
    }

    public string GetTempDirectory()
    {
        return Path.GetTempPath();
    }
}
#endif
```

## 5. Android 平台實作

### 5.1 AndroidFileSystem

```csharp
#if ANDROID
namespace MD_Viewer.Platforms.Android;

using MD_Viewer.Services.Platform;
using MD_Viewer.Models;
using AndroidX.DocumentFile.Provider;
using Android.Content;
using Android.Net;

public class AndroidFileSystem : IPlatformFileSystem
{
    private readonly Android.App.Activity _activity;
    private Uri? _treeUri;

    public AndroidFileSystem()
    {
        _activity = Platform.CurrentActivity 
            ?? throw new InvalidOperationException("Activity is not available");
    }

    public async Task<List<DriveInfo>> GetDrivesAsync()
    {
        // Android 沒有傳統的磁碟概念
        // 返回常用目錄
        return await Task.FromResult(new List<DriveInfo>
        {
            new DriveInfo
            {
                Name = "下載",
                Label = "Downloads",
                Path = "/storage/emulated/0/Download",
                IsReady = true
            },
            new DriveInfo
            {
                Name = "文件",
                Label = "Documents",
                Path = "/storage/emulated/0/Documents",
                IsReady = true
            }
        });
    }

    public async Task<string?> RequestFileAccessAsync()
    {
        return await MainThread.InvokeOnMainThreadAsync(() =>
        {
            var intent = new Intent(Intent.ActionOpenDocument);
            intent.AddCategory(Intent.CategoryOpenable);
            intent.SetType("*/*");
            intent.PutExtra(Intent.ExtraMimeTypes, new[] { "text/markdown", "text/plain" });

            // 使用 Activity Result API
            // 需要在 Activity 中處理結果
            return null; // 實際實作需要透過 Activity Result
        });
    }

    public async Task<string?> RequestDirectoryAccessAsync()
    {
        return await MainThread.InvokeOnMainThreadAsync(() =>
        {
            var intent = new Intent(Intent.ActionOpenDocumentTree);
            
            // 使用 Activity Result API
            // 需要在 Activity 中處理結果
            return null; // 實際實作需要透過 Activity Result
        });
    }

    public async Task<bool> HasFileAccessAsync(string path)
    {
        return await Task.Run(() =>
        {
            try
            {
                // 使用 SAF API 檢查
                if (_treeUri != null)
                {
                    var documentFile = DocumentFile.FromTreeUri(_activity, _treeUri);
                    return documentFile?.Exists() ?? false;
                }
                
                return Directory.Exists(path) || File.Exists(path);
            }
            catch
            {
                return false;
            }
        });
    }

    public string GetAppDataDirectory()
    {
        return _activity.FilesDir?.AbsolutePath 
            ?? Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
                "MD_Viewer"
            );
    }

    public string GetTempDirectory()
    {
        return _activity.CacheDir?.AbsolutePath ?? Path.GetTempPath();
    }

    public void SetTreeUri(Uri uri)
    {
        _treeUri = uri;
    }
}
#endif
```

## 6. 服務註冊

### 6.1 平台特定服務註冊

```csharp
// MauiProgram.cs
public static class MauiProgram
{
    public static MauiApp CreateMauiApp()
    {
        var builder = MauiApp.CreateBuilder();
        builder
            .UseMauiApp<App>()
            .ConfigureFonts(fonts => { /* ... */ });

        // 註冊平台特定服務
        ConfigurePlatformServices(builder.Services);
        
        // 註冊核心服務
        ConfigureServices(builder.Services);
        
        return builder.Build();
    }

    private static void ConfigurePlatformServices(IServiceCollection services)
    {
        #if WINDOWS
        services.AddSingleton<IPlatformFileSystem, WindowsFileSystem>();
        #elif MACCATALYST
        services.AddSingleton<IPlatformFileSystem, MacFileSystem>();
        #elif ANDROID
        services.AddSingleton<IPlatformFileSystem, AndroidFileSystem>();
        #endif
    }

    private static void ConfigureServices(IServiceCollection services)
    {
        // 核心服務依賴 IPlatformFileSystem
        services.AddSingleton<IFileSystemService, FileSystemService>();
        // ... 其他服務
    }
}
```

## 7. 平台特定功能處理

### 7.1 條件編譯

使用 `#if` 指令處理平台特定程式碼：

```csharp
public class FileSystemService : IFileSystemService
{
    private readonly IPlatformFileSystem _platformFileSystem;

    public async Task<List<DriveInfo>> GetDrivesAsync()
    {
        return await _platformFileSystem.GetDrivesAsync();
    }

    public async Task<string?> RequestFileAccessAsync()
    {
        #if WINDOWS
        // Windows 特定邏輯
        return await RequestWindowsFileAccessAsync();
        #elif MACCATALYST
        // macOS 特定邏輯
        return await RequestMacFileAccessAsync();
        #elif ANDROID
        // Android 特定邏輯
        return await RequestAndroidFileAccessAsync();
        #else
        return null;
        #endif
    }

    #if WINDOWS
    private async Task<string?> RequestWindowsFileAccessAsync()
    {
        // Windows 實作
    }
    #endif

    #if MACCATALYST
    private async Task<string?> RequestMacFileAccessAsync()
    {
        // macOS 實作
    }
    #endif

    #if ANDROID
    private async Task<string?> RequestAndroidFileAccessAsync()
    {
        // Android 實作
    }
    #endif
}
```

### 7.2 平台特定擴充方法

```csharp
namespace MD_Viewer.Extensions;

public static class PlatformExtensions
{
    public static string GetPlatformName()
    {
        #if WINDOWS
        return "Windows";
        #elif MACCATALYST
        return "macOS";
        #elif ANDROID
        return "Android";
        #elif IOS
        return "iOS";
        #else
        return "Unknown";
        #endif
    }

    public static bool IsDesktop()
    {
        #if WINDOWS || MACCATALYST
        return true;
        #else
        return false;
        #endif
    }

    public static bool IsMobile()
    {
        #if ANDROID || IOS
        return true;
        #else
        return false;
        #endif
    }
}
```

## 8. 測試支援

### 8.1 模擬平台服務

```csharp
namespace MD_Viewer.Tests.Mocks;

public class MockPlatformFileSystem : IPlatformFileSystem
{
    private readonly List<DriveInfo> _drives = new();
    private readonly Dictionary<string, string> _files = new();

    public Task<List<DriveInfo>> GetDrivesAsync()
    {
        return Task.FromResult(_drives);
    }

    public Task<string?> RequestFileAccessAsync()
    {
        return Task.FromResult<string?>(null);
    }

    public Task<string?> RequestDirectoryAccessAsync()
    {
        return Task.FromResult<string?>(null);
    }

    public Task<bool> HasFileAccessAsync(string path)
    {
        return Task.FromResult(_files.ContainsKey(path));
    }

    public string GetAppDataDirectory()
    {
        return Path.GetTempPath();
    }

    public string GetTempDirectory()
    {
        return Path.GetTempPath();
    }

    // 測試輔助方法
    public void AddDrive(DriveInfo drive)
    {
        _drives.Add(drive);
    }

    public void AddFile(string path, string content)
    {
        _files[path] = content;
    }
}
```

## 9. 平台特定 UI 適配

### 9.1 響應式佈局

```xml
<!-- MainPage.xaml -->
<Grid>
    <Grid.RowDefinitions>
        <RowDefinition Height="Auto" />
        <RowDefinition Height="*" />
    </Grid.RowDefinitions>

    <!-- 工具列 -->
    <Toolbar Grid.Row="0" />

    <!-- 內容區 -->
    <Grid Grid.Row="1">
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="*" />
            <ColumnDefinition Width="*" />
        </Grid.ColumnDefinitions>

        <!-- 檔案樹 -->
        <FileTreeView Grid.Column="0" />

        <!-- 預覽/編輯區 -->
        <ContentView Grid.Column="1">
            <OnPlatform x:TypeArguments="View">
                <On Platform="Desktop">
                    <!-- 桌面版佈局 -->
                    <Grid>
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="*" />
                            <ColumnDefinition Width="*" />
                        </Grid.ColumnDefinitions>
                        <Editor Grid.Column="0" />
                        <WebView Grid.Column="1" />
                    </Grid>
                </On>
                <On Platform="Mobile">
                    <!-- 行動版佈局（堆疊） -->
                    <StackLayout>
                        <Editor />
                        <WebView />
                    </StackLayout>
                </On>
            </OnPlatform>
        </ContentView>
    </Grid>
</Grid>
```

### 9.2 平台特定樣式

```xml
<!-- Resources/Styles.xaml -->
<Style x:Key="FileTreeStyle" TargetType="CollectionView">
    <Setter Property="BackgroundColor">
        <Setter.Value>
            <OnPlatform x:TypeArguments="Color">
                <On Platform="Windows" Value="White" />
                <On Platform="MacCatalyst" Value="White" />
                <On Platform="Android" Value="#F5F5F5" />
            </OnPlatform>
        </Setter.Value>
    </Setter>
</Style>
```

## 10. 最佳實踐

### 10.1 平台檢測

- 使用 `#if` 進行編譯時平台檢測
- 使用 `DeviceInfo.Platform` 進行執行時平台檢測
- 優先使用依賴注入而非直接平台檢測

### 10.2 錯誤處理

- 平台特定錯誤應轉換為通用異常
- 提供使用者友好的錯誤訊息
- 記錄詳細的錯誤資訊用於除錯

### 10.3 效能考量

- 平台特定操作應使用非同步方法
- 避免在主執行緒執行長時間操作
- 使用快取減少平台 API 呼叫

