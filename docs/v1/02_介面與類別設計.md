# 介面與類別設計文件

## 1. 核心介面定義

### 1.1 IFileSystemService

```csharp
namespace MD_Viewer.Services;

/// <summary>
/// 檔案系統服務介面，提供跨平台檔案操作
/// </summary>
public interface IFileSystemService
{
    /// <summary>
    /// 取得可用的磁碟/根目錄列表
    /// </summary>
    Task<List<DriveInfo>> GetDrivesAsync();

    /// <summary>
    /// 讀取目錄結構（遞迴）
    /// </summary>
    /// <param name="path">目錄路徑</param>
    /// <param name="cancellationToken">取消令牌</param>
    Task<List<FileNode>> ReadDirectoryAsync(string path, CancellationToken cancellationToken = default);

    /// <summary>
    /// 讀取檔案內容
    /// </summary>
    Task<string> ReadFileAsync(string filePath, CancellationToken cancellationToken = default);

    /// <summary>
    /// 寫入檔案內容
    /// </summary>
    Task WriteFileAsync(string filePath, string content, CancellationToken cancellationToken = default);

    /// <summary>
    /// 檢查是否為 Markdown 檔案
    /// </summary>
    bool IsMarkdownFile(string filePath);

    /// <summary>
    /// 請求檔案存取權限（平台特定）
    /// </summary>
    Task<string?> RequestFileAccessAsync();
}
```

### 1.2 IPlatformFileSystem

```csharp
namespace MD_Viewer.Services.Platform;

/// <summary>
/// 平台特定檔案系統介面
/// </summary>
public interface IPlatformFileSystem
{
    /// <summary>
    /// 取得平台特定的磁碟/根目錄列表
    /// </summary>
    Task<List<DriveInfo>> GetDrivesAsync();

    /// <summary>
    /// 請求檔案存取權限
    /// </summary>
    Task<string?> RequestFileAccessAsync();

    /// <summary>
    /// 檢查是否有檔案存取權限
    /// </summary>
    Task<bool> HasFileAccessAsync(string path);
}
```

### 1.3 IMarkdownService

```csharp
namespace MD_Viewer.Services;

/// <summary>
/// Markdown 處理服務介面
/// </summary>
public interface IMarkdownService
{
    /// <summary>
    /// 將 Markdown 轉換為 HTML
    /// </summary>
    string RenderToHtml(string markdown);

    /// <summary>
    /// 驗證 Markdown 格式
    /// </summary>
    bool ValidateMarkdown(string markdown, out string? errorMessage);

    /// <summary>
    /// 取得 Markdown 的元資料（標題、作者等）
    /// </summary>
    MarkdownMetadata ExtractMetadata(string markdown);
}
```

### 1.4 IExportService

```csharp
namespace MD_Viewer.Services;

/// <summary>
/// 匯出服務介面
/// </summary>
public interface IExportService
{
    /// <summary>
    /// 匯出為 HTML
    /// </summary>
    Task ExportToHtmlAsync(string markdown, string outputPath, ExportOptions? options = null);

    /// <summary>
    /// 匯出為 PDF
    /// </summary>
    Task ExportToPdfAsync(string markdown, string outputPath, ExportOptions? options = null);

    /// <summary>
    /// 匯出為 DOCX
    /// </summary>
    Task ExportToDocxAsync(string markdown, string outputPath, ExportOptions? options = null);

    /// <summary>
    /// 匯出為 ODF
    /// </summary>
    Task ExportToOdfAsync(string markdown, string outputPath, ExportOptions? options = null);

    /// <summary>
    /// 取得支援的匯出格式
    /// </summary>
    List<ExportFormat> GetSupportedFormats();
}
```

## 2. 資料模型

### 2.1 FileNode

```csharp
namespace MD_Viewer.Models;

/// <summary>
/// 檔案節點模型
/// </summary>
public class FileNode : ObservableObject
{
    private bool _isExpanded;
    private bool _isSelected;

    /// <summary>
    /// 節點類型
    /// </summary>
    public FileNodeType Type { get; set; }

    /// <summary>
    /// 名稱
    /// </summary>
    public string Name { get; set; } = string.Empty;

    /// <summary>
    /// 完整路徑
    /// </summary>
    public string Path { get; set; } = string.Empty;

    /// <summary>
    /// 子節點（僅目錄有）
    /// </summary>
    public ObservableCollection<FileNode> Children { get; set; } = new();

    /// <summary>
    /// 是否展開（僅目錄）
    /// </summary>
    public bool IsExpanded
    {
        get => _isExpanded;
        set => SetProperty(ref _isExpanded, value);
    }

    /// <summary>
    /// 是否選中
    /// </summary>
    public bool IsSelected
    {
        get => _isSelected;
        set => SetProperty(ref _isSelected, value);
    }

    /// <summary>
    /// 圖示（根據類型）
    /// </summary>
    public string Icon => Type == FileNodeType.Directory ? "folder.png" : "file.png";

    /// <summary>
    /// 是否有子節點
    /// </summary>
    public bool HasChildren => Children?.Count > 0;
}

public enum FileNodeType
{
    Directory,
    File
}
```

### 2.2 DriveInfo

```csharp
namespace MD_Viewer.Models;

/// <summary>
/// 磁碟資訊模型
/// </summary>
public class DriveInfo
{
    public string Name { get; set; } = string.Empty;
    public string Label { get; set; } = string.Empty;
    public string Path { get; set; } = string.Empty;
    public bool IsReady { get; set; }
    public long? TotalSize { get; set; }
    public long? AvailableSpace { get; set; }
}
```

### 2.3 ExportOptions

```csharp
namespace MD_Viewer.Models;

/// <summary>
/// 匯出選項
/// </summary>
public class ExportOptions
{
    /// <summary>
    /// 是否包含 CSS 樣式
    /// </summary>
    public bool IncludeStyles { get; set; } = true;

    /// <summary>
    /// 自訂 CSS 樣式路徑
    /// </summary>
    public string? CustomCssPath { get; set; }

    /// <summary>
    /// PDF 頁面大小
    /// </summary>
    public PdfPageSize PageSize { get; set; } = PdfPageSize.A4;

    /// <summary>
    /// PDF 頁面方向
    /// </summary>
    public PdfPageOrientation Orientation { get; set; } = PdfPageOrientation.Portrait;

    /// <summary>
    /// 是否包含頁碼
    /// </summary>
    public bool IncludePageNumbers { get; set; } = true;

    /// <summary>
    /// 標題
    /// </summary>
    public string? Title { get; set; }

    /// <summary>
    /// 作者
    /// </summary>
    public string? Author { get; set; }
}

public enum PdfPageSize
{
    A4,
    Letter,
    Legal
}

public enum PdfPageOrientation
{
    Portrait,
    Landscape
}
```

### 2.4 ExportFormat

```csharp
namespace MD_Viewer.Models;

/// <summary>
/// 匯出格式
/// </summary>
public class ExportFormat
{
    public string Name { get; set; } = string.Empty;
    public string Extension { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public bool IsEnabled { get; set; } = true;
}
```

### 2.5 MarkdownMetadata

```csharp
namespace MD_Viewer.Models;

/// <summary>
/// Markdown 元資料
/// </summary>
public class MarkdownMetadata
{
    public string? Title { get; set; }
    public string? Author { get; set; }
    public DateTime? Date { get; set; }
    public List<string> Tags { get; set; } = new();
    public string? Description { get; set; }
}
```

## 3. ViewModel 設計

### 3.1 MainViewModel

```csharp
namespace MD_Viewer.ViewModels;

public partial class MainViewModel : ObservableObject
{
    private readonly IFileSystemService _fileSystemService;
    private readonly IMarkdownService _markdownService;
    private readonly IExportService _exportService;
    private readonly IMessenger _messenger;

    private ViewMode _currentMode = ViewMode.Preview;
    private FileNode? _currentFile;
    private string _currentFileContent = string.Empty;
    private bool _isLoading;

    public MainViewModel(
        IFileSystemService fileSystemService,
        IMarkdownService markdownService,
        IExportService exportService,
        IMessenger messenger)
    {
        _fileSystemService = fileSystemService;
        _markdownService = markdownService;
        _exportService = exportService;
        _messenger = messenger;

        // 註冊訊息
        _messenger.Register<FileSelectedMessage>(this, OnFileSelected);
    }

    public ViewMode CurrentMode
    {
        get => _currentMode;
        set => SetProperty(ref _currentMode, value);
    }

    public FileNode? CurrentFile
    {
        get => _currentFile;
        set => SetProperty(ref _currentFile, value);
    }

    public string CurrentFileContent
    {
        get => _currentFileContent;
        set => SetProperty(ref _currentFileContent, value);
    }

    public bool IsLoading
    {
        get => _isLoading;
        set => SetProperty(ref _isLoading, value);
    }

    [RelayCommand]
    public void ToggleEditMode()
    {
        CurrentMode = CurrentMode == ViewMode.Preview ? ViewMode.Edit : ViewMode.Preview;
    }

    [RelayCommand]
    public async Task ExportAsync(ExportFormat format)
    {
        if (string.IsNullOrEmpty(CurrentFileContent))
            return;

        try
        {
            IsLoading = true;
            // 匯出邏輯
            await _exportService.ExportAsync(format, CurrentFileContent, CurrentFile?.Path ?? "");
        }
        catch (Exception ex)
        {
            // 錯誤處理
        }
        finally
        {
            IsLoading = false;
        }
    }

    private async void OnFileSelected(object recipient, FileSelectedMessage message)
    {
        if (message.Value?.Type != FileNodeType.File)
            return;

        await LoadFileAsync(message.Value.Path);
    }

    private async Task LoadFileAsync(string filePath)
    {
        try
        {
            IsLoading = true;
            CurrentFileContent = await _fileSystemService.ReadFileAsync(filePath);
        }
        catch (Exception ex)
        {
            // 錯誤處理
        }
        finally
        {
            IsLoading = false;
        }
    }
}

public enum ViewMode
{
    Preview,
    Edit
}
```

### 3.2 FileTreeViewModel

```csharp
namespace MD_Viewer.ViewModels;

public partial class FileTreeViewModel : ObservableObject
{
    private readonly IFileSystemService _fileSystemService;
    private readonly IMessenger _messenger;

    private string? _selectedDrive;
    private FileNode? _selectedNode;
    private ObservableCollection<FileNode> _fileTree = new();

    public FileTreeViewModel(
        IFileSystemService fileSystemService,
        IMessenger messenger)
    {
        _fileSystemService = fileSystemService;
        _messenger = messenger;
    }

    public ObservableCollection<DriveInfo> Drives { get; } = new();
    public ObservableCollection<FileNode> FileTree
    {
        get => _fileTree;
        set => SetProperty(ref _fileTree, value);
    }

    public string? SelectedDrive
    {
        get => _selectedDrive;
        set
        {
            if (SetProperty(ref _selectedDrive, value) && value != null)
            {
                LoadDirectoryAsync(value);
            }
        }
    }

    public FileNode? SelectedNode
    {
        get => _selectedNode;
        set
        {
            if (SetProperty(ref _selectedNode, value) && value != null)
            {
                _messenger.Send(new FileSelectedMessage(value));
            }
        }
    }

    [RelayCommand]
    public async Task LoadDrivesAsync()
    {
        var drives = await _fileSystemService.GetDrivesAsync();
        Drives.Clear();
        foreach (var drive in drives)
        {
            Drives.Add(drive);
        }
    }

    [RelayCommand]
    public async Task LoadDirectoryAsync(string path)
    {
        try
        {
            var nodes = await _fileSystemService.ReadDirectoryAsync(path);
            FileTree.Clear();
            foreach (var node in nodes)
            {
                FileTree.Add(node);
            }
        }
        catch (Exception ex)
        {
            // 錯誤處理
        }
    }

    [RelayCommand]
    public async Task ExpandNodeAsync(FileNode node)
    {
        if (node.Type != FileNodeType.Directory || node.Children.Count > 0)
            return;

        try
        {
            var children = await _fileSystemService.ReadDirectoryAsync(node.Path);
            foreach (var child in children)
            {
                node.Children.Add(child);
            }
            node.IsExpanded = true;
        }
        catch (Exception ex)
        {
            // 錯誤處理
        }
    }
}
```

### 3.3 PreviewViewModel

```csharp
namespace MD_Viewer.ViewModels;

public partial class PreviewViewModel : ObservableObject
{
    private readonly IMarkdownService _markdownService;
    private string _renderedHtml = string.Empty;

    public PreviewViewModel(IMarkdownService markdownService)
    {
        _markdownService = markdownService;
    }

    public string RenderedHtml
    {
        get => _renderedHtml;
        set => SetProperty(ref _renderedHtml, value);
    }

    public void UpdatePreview(string markdown)
    {
        RenderedHtml = _markdownService.RenderToHtml(markdown);
    }
}
```

## 4. 服務實作類別

### 4.1 FileSystemService

```csharp
namespace MD_Viewer.Services;

public class FileSystemService : IFileSystemService
{
    private readonly IPlatformFileSystem _platformFileSystem;
    private static readonly string[] MarkdownExtensions = 
        { ".md", ".markdown", ".mdown", ".mkd", ".mkdn", ".mdwn" };

    public FileSystemService(IPlatformFileSystem platformFileSystem)
    {
        _platformFileSystem = platformFileSystem;
    }

    public async Task<List<DriveInfo>> GetDrivesAsync()
    {
        return await _platformFileSystem.GetDrivesAsync();
    }

    public async Task<List<FileNode>> ReadDirectoryAsync(string path, CancellationToken cancellationToken = default)
    {
        var nodes = new List<FileNode>();

        try
        {
            var items = Directory.GetFileSystemEntries(path);
            
            foreach (var item in items)
            {
                cancellationToken.ThrowIfCancellationRequested();

                if (Directory.Exists(item))
                {
                    nodes.Add(new FileNode
                    {
                        Type = FileNodeType.Directory,
                        Name = Path.GetFileName(item),
                        Path = item
                    });
                }
                else if (File.Exists(item) && IsMarkdownFile(item))
                {
                    nodes.Add(new FileNode
                    {
                        Type = FileNodeType.File,
                        Name = Path.GetFileName(item),
                        Path = item
                    });
                }
            }
        }
        catch (UnauthorizedAccessException)
        {
            // 記錄錯誤但不中斷
        }

        return nodes;
    }

    public async Task<string> ReadFileAsync(string filePath, CancellationToken cancellationToken = default)
    {
        return await File.ReadAllTextAsync(filePath, cancellationToken);
    }

    public async Task WriteFileAsync(string filePath, string content, CancellationToken cancellationToken = default)
    {
        await File.WriteAllTextAsync(filePath, content, cancellationToken);
    }

    public bool IsMarkdownFile(string filePath)
    {
        var extension = Path.GetExtension(filePath).ToLowerInvariant();
        return MarkdownExtensions.Contains(extension);
    }

    public async Task<string?> RequestFileAccessAsync()
    {
        return await _platformFileSystem.RequestFileAccessAsync();
    }
}
```

### 4.2 MarkdownService

```csharp
namespace MD_Viewer.Services;

public class MarkdownService : IMarkdownService
{
    private readonly MarkdownPipeline _pipeline;

    public MarkdownService()
    {
        _pipeline = new MarkdownPipelineBuilder()
            .UseAdvancedExtensions()
            .UseMathematics()
            .UseSyntaxHighlighting()
            .Build();
    }

    public string RenderToHtml(string markdown)
    {
        if (string.IsNullOrEmpty(markdown))
            return string.Empty;

        return Markdig.Markdown.ToHtml(markdown, _pipeline);
    }

    public bool ValidateMarkdown(string markdown, out string? errorMessage)
    {
        errorMessage = null;
        // 基本驗證邏輯
        return true;
    }

    public MarkdownMetadata ExtractMetadata(string markdown)
    {
        // 從 Front Matter 提取元資料
        var metadata = new MarkdownMetadata();
        // 實作提取邏輯
        return metadata;
    }
}
```

### 4.3 ExportService

```csharp
namespace MD_Viewer.Services;

public class ExportService : IExportService
{
    private readonly IMarkdownService _markdownService;
    private readonly HtmlExporter _htmlExporter;
    private readonly PdfExporter _pdfExporter;
    private readonly DocxExporter _docxExporter;
    private readonly OdfExporter _odfExporter;

    public ExportService(
        IMarkdownService markdownService,
        HtmlExporter htmlExporter,
        PdfExporter pdfExporter,
        DocxExporter docxExporter,
        OdfExporter odfExporter)
    {
        _markdownService = markdownService;
        _htmlExporter = htmlExporter;
        _pdfExporter = pdfExporter;
        _docxExporter = docxExporter;
        _odfExporter = odfExporter;
    }

    public async Task ExportToHtmlAsync(string markdown, string outputPath, ExportOptions? options = null)
    {
        await _htmlExporter.ExportAsync(markdown, outputPath, options);
    }

    public async Task ExportToPdfAsync(string markdown, string outputPath, ExportOptions? options = null)
    {
        await _pdfExporter.ExportAsync(markdown, outputPath, options);
    }

    public async Task ExportToDocxAsync(string markdown, string outputPath, ExportOptions? options = null)
    {
        await _docxExporter.ExportAsync(markdown, outputPath, options);
    }

    public async Task ExportToOdfAsync(string markdown, string outputPath, ExportOptions? options = null)
    {
        await _odfExporter.ExportAsync(markdown, outputPath, options);
    }

    public List<ExportFormat> GetSupportedFormats()
    {
        return new List<ExportFormat>
        {
            new() { Name = "HTML", Extension = ".html", Description = "HTML 網頁格式" },
            new() { Name = "PDF", Extension = ".pdf", Description = "PDF 文件格式" },
            new() { Name = "DOCX", Extension = ".docx", Description = "Microsoft Word 格式" },
            new() { Name = "ODF", Extension = ".odt", Description = "OpenDocument 格式" }
        };
    }
}
```

## 5. 訊息類別

### 5.1 FileSelectedMessage

```csharp
namespace MD_Viewer.Messages;

public class FileSelectedMessage : ValueChangedMessage<FileNode>
{
    public FileSelectedMessage(FileNode file) : base(file) { }
}
```

### 5.2 ContentChangedMessage

```csharp
namespace MD_Viewer.Messages;

public class ContentChangedMessage : ValueChangedMessage<string>
{
    public ContentChangedMessage(string content) : base(content) { }
}
```

